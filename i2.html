<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>index2 — Slice Writer (persistent cuts)</title>

  <style>
    :root{
      --bg: #f3f2ef;
      --paper: #f7f6f3;
      --ink: #171717;
      --muted: rgba(0,0,0,.52);

      --accent: #d3572e;
      --accent-2: #b84a2a;

      --radius: 22px;
      --col: 720px;

      --space-2: 12px;
      --space-3: 16px;
      --space-4: 24px;
      --space-5: 32px;

      /* Soft stacked shadows (calm) */
      --shadow-1: 0 0 0 1px rgba(0,0,0,.05);
      --shadow-2: 0 1px 1px rgba(0,0,0,.06);
      --shadow-3: 0 3px 6px rgba(0,0,0,.06);
      --shadow-4: 0 12px 24px rgba(0,0,0,.08);
    }

    html, body { height: 100%; margin: 0; }
    body{
      color: var(--ink);
      background: var(--bg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Grid + hatch like refs */
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: .55;
      background:
        linear-gradient(to right, rgba(0,0,0,.035) 1px, transparent 1px) 0 0 / 120px 120px,
        linear-gradient(to bottom, rgba(0,0,0,.035) 1px, transparent 1px) 0 0 / 120px 120px,
        linear-gradient(to right, rgba(0,0,0,.02) 1px, transparent 1px) 0 0 / 24px 24px,
        linear-gradient(to bottom, rgba(0,0,0,.02) 1px, transparent 1px) 0 0 / 24px 24px,
        repeating-linear-gradient(135deg, rgba(0,0,0,.018) 0 2px, transparent 2px 10px);
      mix-blend-mode: multiply;
    }
    /* Paper grain */
    body::after{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: .10;
      background-image: url('data:image/svg+xml;utf8,\
<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160">\
<filter id="n"><feTurbulence type="fractalNoise" baseFrequency=".9" numOctaves="2" stitchTiles="stitch"/></filter>\
<rect width="160" height="160" filter="url(%23n)" opacity=".55"/></svg>');
      mix-blend-mode: multiply;
    }

    .app{
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: clamp(18px, 3vw, 40px);
    }

    .frame{
      width: min(1180px, 98vw);
      height: min(760px, 90vh);
      border-radius: 28px;
      background: rgba(255,255,255,.35);
      box-shadow: var(--shadow-1), var(--shadow-3), var(--shadow-4);
      border: 1px solid rgba(0,0,0,.05);
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(2px);
    }

    .chrome{
      position: absolute;
      top: 16px;
      right: 18px;
      display: flex;
      gap: 8px;
      opacity: .85;
      z-index: 10;
    }
    .dot{
      width: 10px; height: 10px; border-radius: 999px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.08) inset;
      background: rgba(0,0,0,.10);
    }
    .dot.a{ background: #d3572e; }
    .dot.b{ background: rgba(0,0,0,.12); }
    .dot.c{ background: rgba(0,0,0,.10); }

    .sheetWrap{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: clamp(16px, 2.4vw, 34px);
    }

    .paper{
      width: min(var(--col), 92%);
      height: 100%;
      max-height: calc(90vh - 110px);
      border-radius: var(--radius);
      background: color-mix(in srgb, var(--paper) 92%, white 8%);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: var(--shadow-1), var(--shadow-2), var(--shadow-3);
      display: grid;
      grid-template-rows: auto 1fr auto;
      overflow: hidden;
      position: relative;
    }

    .paperHeader{
      padding: var(--space-4) var(--space-5) var(--space-3);
      border-bottom: 1px solid rgba(0,0,0,.05);
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items: baseline;
    }
    .brand{
      font-size: 12px;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: rgba(0,0,0,.60);
      white-space: nowrap;
    }
    .hint{
      font-size: 12px;
      color: rgba(0,0,0,.45);
      line-height: 1.35;
    }
    .mono{ font-family: inherit; }

    .editorZone{
      padding: var(--space-5);
      overflow: auto;
    }
    .editor{
      outline: none;
      min-height: 520px;
      font-size: 18px;
      line-height: 1.65;
      letter-spacing: .01em;
      color: rgba(0,0,0,.88);
      caret-color: var(--accent);
      white-space: pre-wrap;
    }
    .paperFooter{
      padding: var(--space-3) var(--space-5) var(--space-4);
      border-top: 1px solid rgba(0,0,0,.05);
      display:flex;
      justify-content: space-between;
      color: rgba(0,0,0,.45);
      font-size: 12px;
    }

    /* =========================
       Slice (persistent cut)
       ========================= */

    .slice{
      display: block;
      margin: 18px 0 18px;
      position: relative;
    }

    /* tear lines (illusion) */
    .slice::before,
    .slice::after{
      content:"";
      display:block;
      height: 10px;
      margin: 0 0 10px;
      background: linear-gradient(to bottom,
        rgba(0,0,0,0),
        rgba(0,0,0,.11),
        rgba(0,0,0,0)
      );
      opacity: .55;
      filter: blur(.2px);
    }
    .slice::after{
      margin: 10px 0 0;
      opacity: .45;
    }

    /* The "opening" area: gutters + card */
    .sliceRow{
      display: grid;
      grid-template-columns: 1fr min(980px, 92%) 1fr; /* gutters L/R */
      align-items: stretch;
      gap: 0;
    }

    .gutter{
      cursor: pointer;
      /* invisible click zones */
      background: transparent;
      min-height: 220px;
    }

    .gutter:hover{
      background: linear-gradient(to right, rgba(211,87,46,.10), transparent);
    }
    .gutter.right:hover{
      background: linear-gradient(to left, rgba(211,87,46,.10), transparent);
    }

    .revealCard{
      border-radius: 26px;
      border: 1px solid rgba(0,0,0,.07);
      background: rgba(255,255,255,.48);
      box-shadow: var(--shadow-1), var(--shadow-3), var(--shadow-4);
      overflow: hidden;
      backdrop-filter: blur(3px);
    }

    .blueprint{
      padding: 26px 26px 20px;
      background:
        linear-gradient(to right, rgba(0,0,0,.05) 1px, transparent 1px) 0 0 / 44px 44px,
        linear-gradient(to bottom, rgba(0,0,0,.05) 1px, transparent 1px) 0 0 / 44px 44px,
        rgba(246,246,244,.75);
    }

    .revealTop{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 16px;
      padding-bottom: 14px;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }

    .revealTitle{
      font-size: 13px;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: rgba(0,0,0,.62);
      display:flex;
      gap: 12px;
      align-items:baseline;
      flex-wrap: wrap;
    }

    .badge{
      font-size: 12px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--accent-2);
      border-left: 3px solid var(--accent);
      padding-left: 10px;
      font-weight: 700;
    }

    .revealActions{
      color: rgba(0,0,0,.45);
      font-size: 12px;
      white-space: nowrap;
    }

    .revealBody{
      padding: 18px 2px 2px;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 18px;
    }

    .panel{
      border-radius: 20px;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.65);
      box-shadow: var(--shadow-1), var(--shadow-2);
      overflow: hidden;
    }
    .panelHeader{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(0,0,0,.08);
      font-size: 12px;
      letter-spacing: .10em;
      text-transform: uppercase;
      color: rgba(0,0,0,.55);
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
    }
    .panelBody{
      padding: 16px;
      color: rgba(0,0,0,.78);
      font-size: 14px;
      line-height: 1.55;
      white-space: pre-wrap;
    }

    .muted{ color: rgba(0,0,0,.52); }

    /* slice should not be editable */
    .slice[contenteditable="false"]{ user-select: text; }

    @media (max-width: 860px){
      .revealBody{ grid-template-columns: 1fr; }
      .sliceRow{ grid-template-columns: 18px 1fr 18px; } /* thin gutters on mobile */
      .gutter{ min-height: 140px; }
    }
  </style>
</head>

<body data-ui-version="v2">
  <div class="app">
    <div class="frame" role="application" aria-label="Retcon Slice Writer v2">
      <div class="chrome" aria-hidden="true">
        <span class="dot a"></span><span class="dot b"></span><span class="dot c"></span>
      </div>

      <div class="sheetWrap">
        <div class="paper" aria-label="Área de escrita">
          <div class="paperHeader">
            <div class="brand">Index2 / Slice Writer</div>
            <div class="hint">
              Comandos inline:
              <span class="mono">--d</span> define (palavra anterior) •
              <span class="mono">--v</span> vocabulário •
              <span class="mono">--h</span> ajuda •
              <span class="mono">--c</span> consulta
              <br/>
              Fechar corte: clique no vazio da esquerda/direita do cartão do corte.
            </div>
          </div>

          <div class="editorZone">
            <div id="editor" class="editor" contenteditable="true" spellcheck="false" aria-label="Editor">
Querido e gentil leitor, doravante --d

Agora posso continuar escrevendo enquanto a definição fica ali embaixo.
Abra vários cortes: --h, --v, --c, e outras palavras --d
            </div>
          </div>

          <div class="paperFooter">
            <div><span class="mono" id="status">ready</span></div>
            <div class="muted">Sem modais. Só camadas.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const editor = document.getElementById('editor');
    const statusEl = document.getElementById('status');

    const vocab = {
      "doravante": "A partir de agora; daqui em diante.",
      "outrossim": "Além disso; do mesmo modo; igualmente.",
      "amiúde": "Com frequência; muitas vezes.",
      "destarte": "Dessa maneira; portanto.",
      "mormente": "Principalmente; sobretudo.",
    };

    function setStatus(msg){ statusEl.textContent = msg; }

    // -------- caret helpers (robust enough for MVP) --------
    function getSelectionRange(){
      const sel = window.getSelection();
      if(!sel || sel.rangeCount === 0) return null;
      return sel.getRangeAt(0);
    }

    function getTextBeforeCaret(){
      const range = getSelectionRange();
      if(!range) return "";
      const pre = range.cloneRange();
      pre.selectNodeContents(editor);
      pre.setEnd(range.endContainer, range.endOffset);
      return pre.toString();
    }

    function deleteCharsBeforeCaret(n){
      const range = getSelectionRange();
      if(!range) return;

      // Move a new range backwards by n chars within the editor
      const pre = range.cloneRange();
      pre.collapse(true);

      // Walk backwards through text nodes to delete n chars
      let remaining = n;

      function prevTextNode(node){
        // Depth-first previous text node within editor
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
        let prev = null;
        while(walker.nextNode()){
          if(walker.currentNode === node) return prev;
          prev = walker.currentNode;
        }
        return prev;
      }

      let node = pre.startContainer;
      let offset = pre.startOffset;

      // If caret isn't in a text node, try to find nearest previous text node
      if(node.nodeType !== Node.TEXT_NODE){
        // convert to previous text node if possible
        const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
        let last = null;
        while(walker.nextNode()) last = walker.currentNode;
        if(!last) return;
        node = last;
        offset = last.textContent.length;
      }

      while(remaining > 0 && node){
        const take = Math.min(remaining, offset);
        const start = offset - take;

        const del = document.createRange();
        del.setStart(node, start);
        del.setEnd(node, offset);
        del.deleteContents();

        remaining -= take;

        if(remaining <= 0) break;

        // move to previous text node
        const p = prevTextNode(node);
        node = p;
        offset = node ? node.textContent.length : 0;
      }
    }

    function insertNodeAtCaret(node){
      const range = getSelectionRange();
      if(!range) return;
      range.collapse(false);
      range.insertNode(node);

      // Move caret after inserted node
      const sel = window.getSelection();
      const after = document.createRange();
      after.setStartAfter(node);
      after.collapse(true);
      sel.removeAllRanges();
      sel.addRange(after);
    }

    // -------- slice creation --------
    let sliceId = 0;

    function makeSlice({badge, title, kind, meta, body, debug}){
      const root = document.createElement('div');
      root.className = 'slice';
      root.setAttribute('contenteditable', 'false');
      root.dataset.sliceId = String(++sliceId);

      root.innerHTML = `
        <div class="sliceRow">
          <div class="gutter left" title="Clique para fechar esta camada"></div>

          <div class="revealCard">
            <div class="blueprint">
              <div class="revealTop">
                <div class="revealTitle">
                  <span class="badge">${escapeHtml(badge)}</span>
                  <span>${escapeHtml(title)}</span>
                </div>
                <div class="revealActions">
                  <span class="muted">${escapeHtml(meta || "")}</span>
                </div>
              </div>

              <div class="revealBody">
                <div class="panel">
                  <div class="panelHeader">
                    <span>${escapeHtml(kind)}</span>
                    <span class="muted">—</span>
                  </div>
                  <div class="panelBody">${escapeHtml(body)}</div>
                </div>

                <div class="panel">
                  <div class="panelHeader">
                    <span>Debug / Contrato</span>
                    <span class="muted">v2</span>
                  </div>
                  <div class="panelBody">${escapeHtml(debug)}</div>
                </div>
              </div>

              <div style="padding: 14px 2px 2px; color: rgba(0,0,0,.46); font-size: 12px;">
                Fechar: clique no vazio da esquerda/direita (o “vão” do rasgo).
              </div>
            </div>
          </div>

          <div class="gutter right" title="Clique para fechar esta camada"></div>
        </div>
      `;

      // Close only via gutters (left/right)
      root.querySelector('.gutter.left').addEventListener('click', () => root.remove());
      root.querySelector('.gutter.right').addEventListener('click', () => root.remove());

      return root;
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // -------- command handling --------
    function getLastWordBeforeToken(textBeforeCaret, token){
      // e.g. "doravante --d" => "doravante"
      const idx = textBeforeCaret.lastIndexOf(token);
      if(idx === -1) return "";
      const before = textBeforeCaret.slice(0, idx).trimEnd();
      const m = before.match(/([A-Za-zÀ-ÿ0-9_-]+)\s*$/);
      return m ? m[1] : "";
    }

    function handleCommand(cmd){
      const token = `--${cmd}`;
      const textBefore = getTextBeforeCaret();
      const word = (cmd === 'd' || cmd === 'c') ? getLastWordBeforeToken(textBefore, token) : "";

      const debug = [
        `command: ${token}`,
        `word: ${word || "(none)"}`,
        `behavior: persistent slice`,
        `close: click gutters left/right`,
        `note: multiple slices supported`
      ].join('\n');

      if(cmd === 'h'){
        return makeSlice({
          badge: "01/ HELP",
          title: "Ajuda (inline)",
          kind: "Help",
          meta: "comandos e regras",
          body:
`Como usar:
- "palavra --d" → abre definição da palavra anterior.
- "--v" → abre vocabulário local.
- "--c" → abre consulta (placeholder).
- "--h" → abre ajuda.

Fechar:
- clique no vazio (gutter) à esquerda ou à direita do cartão do corte.

Você continua escrevendo o tempo todo.
Abra quantos cortes quiser.`,
          debug
        });
      }

      if(cmd === 'v'){
        const list = Object.entries(vocab)
          .map(([k,v]) => `• ${k} — ${v}`)
          .join('\n');
        return makeSlice({
          badge: "02/ VOCAB",
          title: "Vocabulário (local)",
          kind: "Vocabulary",
          meta: `${Object.keys(vocab).length} entradas`,
          body: list || "(vazio)",
          debug
        });
      }

      if(cmd === 'd'){
        const w = (word || "").toLowerCase();
        const def = vocab[w] || `Não encontrei definição local para “${word}”.\n\nPróximo passo: ligar sua base real / dicionário offline.`;
        return makeSlice({
          badge: "03/ DEFINE",
          title: `Definição — ${word || "?"}`,
          kind: "Definition",
          meta: word ? "palavra anterior ao comando" : "nenhuma palavra detectada",
          body: def,
          debug
        });
      }

      if(cmd === 'c'){
        return makeSlice({
          badge: "04/ CONSULT",
          title: `Consulta — ${word || "termo"}`,
          kind: "Consult",
          meta: "placeholder (MVP)",
          body:
`Aqui entra sua feature real de consulta:
- busca local
- notas
- integração com o legado (via adapter)
- etc.

No retcon, sempre aparece como corte persistente.`,
          debug
        });
      }

      return makeSlice({
        badge: "00/ UNKNOWN",
        title: "Comando desconhecido",
        kind: "Error",
        meta: token,
        body: `Ainda não existe handler para ${token}.`,
        debug
      });
    }

    function maybeTriggerCommand(){
      // Trigger only when user types whitespace/newline (command completed)
      const textBefore = getTextBeforeCaret();

      // Detect command at the END of textBeforeCaret (allow trailing spaces)
      // Example: "... doravante --d " or "... --h\n"
      const m = textBefore.match(/--([a-z])\s*$/i);
      if(!m) return;

      const cmd = (m[1] || "").toLowerCase();
      const tokenLen = (`--${cmd}`).length;

      // Remove the command token right before caret
      // We remove tokenLen chars, leaving the trailing whitespace
      deleteCharsBeforeCaret(tokenLen);

      // Insert slice block at caret (where the token was)
      const sliceNode = handleCommand(cmd);
      insertNodeAtCaret(sliceNode);

      setStatus(`slice: --${cmd}`);
    }

    // Debounce input
    let t = null;
    editor.addEventListener('input', () => {
      clearTimeout(t);
      t = setTimeout(() => {
        // keep it tight; user should feel instant but not jittery
        maybeTriggerCommand();
      }, 60);
    });

    // Boot
    console.groupCollapsed('[v2] boot');
    console.log('persistent cuts: enabled');
    console.log('close: gutters only');
    console.groupEnd();
    setStatus('ready');
    editor.focus();
  </script>
</body>
</html>
